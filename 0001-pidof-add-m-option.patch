From 85d003437df000929748d63ce80545d0ffdbbfd1 Mon Sep 17 00:00:00 2001
From: Lukas Nykryn <lnykryn@redhat.com>
Date: Tue, 24 Feb 2015 13:19:04 +0100
Subject: [PATCH] pidof: add -m option

---
 man/pidof.8    |   6 ++
 src/killall5.c | 209 ++++++++++++++++++++++++++++++++++++++++++---------------
 2 files changed, 160 insertions(+), 55 deletions(-)

diff --git a/man/pidof.8 b/man/pidof.8
index 06859ed..416a110 100644
--- a/man/pidof.8
+++ b/man/pidof.8
@@ -6,6 +6,7 @@ pidof -- find the process ID of a running program.
 .RB [ \-s ]
 .RB [ \-c ]
 .RB [ \-x ]
+.RB [ \-m ]
 .RB [ \-o
 .IR omitpid ]
 .RB [ \-o
@@ -36,6 +37,11 @@ shells running the named scripts.
 Tells \fIpidof\fP to omit processes with that process id. The special
 pid \fB%PPID\fP can be used to name the parent process of the \fIpidof\fP
 program, in other words the calling shell or shell script.
+.IP -m
+When used with -o, will also omit any processes that have the same
+argv[0] and argv[1] as any explicitly omitted process ids. This can be
+used to avoid multiple shell scripts concurrently calling pidof returning
+each other's pids.
 .SH "EXIT STATUS"
 .TP
 .B 0
diff --git a/src/killall5.c b/src/killall5.c
index e2cb004..29254d0 100644
--- a/src/killall5.c
+++ b/src/killall5.c
@@ -76,8 +76,18 @@ typedef struct {
 	PIDQ		*next;
 } PIDQ_HEAD;
 
+typedef struct _s_omit {
+	struct _s_omit *next;
+	struct _s_omit *prev;
+	pid_t pid;
+} OMIT;
+
 /* List of processes. */
 PROC *plist;
+PROC *olist;
+
+/* List of processes to omit. */
+OMIT *omit;
 
 /* Did we stop all processes ? */
 int sent_sigstop;
@@ -90,6 +100,28 @@ __attribute__ ((format (printf, 2, 3)))
 #endif
 void nsyslog(int pri, char *fmt, ...);
 
+#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L)
+# ifndef  inline
+#  define inline	__inline__
+# endif
+# ifndef  restrict
+#  define restrict	__restrict__
+# endif
+#endif
+#define alignof(type)	((sizeof(type)+(sizeof(void*)-1)) & ~(sizeof(void*)-1))
+
+#ifdef __GNUC__
+static inline void xmemalign(void **, size_t, size_t) __attribute__ ((__nonnull__ (1)));
+#endif
+static inline void xmemalign(void **memptr, size_t alignment, size_t size)
+{
+	if ((posix_memalign(memptr, alignment, size)) < 0) {
+		if (sent_sigstop) kill(-1, SIGCONT);
+		nsyslog(LOG_ERR, "out of memory");
+		exit(1);
+	}
+}
+
 /*
  *	Malloc space, barf if out of memory.
  */
@@ -166,6 +198,20 @@ int readarg(FILE *fp, char *buf, int sz)
 	return (c == EOF && f == 0) ? c : f;
 }
 
+static void clear_omit(void)
+{
+	OMIT *o;
+	PROC *p;
+	for (o = omit; o; o = omit) {
+		omit = omit->next;
+		free(o);
+	}
+	for (p = olist; p; p = olist) {
+		olist = olist->next;
+		free(p);
+	}
+}
+
 /*
  *	Read the proc filesystem.
  *	CWD must be /proc to avoid problems if / is affected by the killing (ie depend on fuse).
@@ -175,6 +221,7 @@ int readproc(int do_stat)
 	DIR		*dir;
 	FILE		*fp;
 	PROC		*p, *n;
+	OMIT		*o, *m;
 	struct dirent	*d;
 	char		path[256];
 	char		buf[BUFLEN];
@@ -335,6 +382,17 @@ int readproc(int do_stat)
 		p->next = plist;
 		plist = p;
 		p->pid = pid;
+		/* Could be smarter, but it's a small list. */
+		m = omit;
+		for (o = omit; m; o = m) {
+			m = o->next;
+			if (o->pid == p->pid) {
+				n = (PROC*)xmalloc(sizeof(PROC));
+				*n = *p;
+				n->next = olist;
+				olist = n;
+			}
+		}
 	}
 	closedir(dir);
 
@@ -481,6 +539,26 @@ PIDQ_HEAD *pidof(char *prog)
 	 return q;
 }
 
+int matches(PROC *o, PROC *p)
+{
+	int ret = 0;
+	char *oargv1, *pargv1;
+	if ((o->argv0 && p->argv0 && !strcmp(o->argv0,p->argv0))) {
+		if (o->argv1 && p->argv1) {
+			if ((oargv1 = canonicalize_file_name(o->argv1)) == NULL)
+				oargv1 = strdup(o->argv1);
+			if ((pargv1 = canonicalize_file_name(p->argv1)) == NULL)
+				pargv1 = strdup(p->argv1);
+			if (! strcmp(oargv1, pargv1)) {
+				ret = 1;
+			}
+			free(oargv1);
+			free(pargv1);
+		}
+	}
+	return ret;
+}
+
 /* Give usage message and exit. */
 void usage(void)
 {
@@ -512,8 +590,7 @@ void nsyslog(int pri, char *fmt, ...)
 
 #define PIDOF_SINGLE	0x01
 #define PIDOF_OMIT	0x02
-
-#define PIDOF_OMITSZ	5
+#define PIDOF_OMIT_OMIT_MATCHES	0x04
 
 /*
  *	Pidof functionality.
@@ -522,19 +599,19 @@ int main_pidof(int argc, char **argv)
 {
 	PIDQ_HEAD	*q;
 	PROC		*p;
-	pid_t		opid[PIDOF_OMITSZ], spid;
+        char		*token, *here;
 	int		f;
 	int		first = 1;
-	int		i, oind, opt, flags = 0;
+	int		opt, flags = 0;
 	int		chroot_check = 0;
 	struct stat	st;
 	char		tmp[512];
 
-	for (oind = PIDOF_OMITSZ-1; oind > 0; oind--)
-		opid[oind] = 0;
-	opterr = 0;
+        olist = (PROC*)0;
+	omit = (OMIT*)0;
+        opterr = 0;
 
-	while ((opt = getopt(argc,argv,"hco:sx")) != EOF) switch (opt) {
+	while ((opt = getopt(argc,argv,"hcmo:sx")) != EOF) switch (opt) {
 		case '?':
 			nsyslog(LOG_ERR,"invalid options on command line!\n");
 			closelog();
@@ -543,22 +620,28 @@ int main_pidof(int argc, char **argv)
 			if (geteuid() == 0) chroot_check = 1;
 			break;
 		case 'o':
-			if (oind >= PIDOF_OMITSZ -1) {
-				nsyslog(LOG_ERR,"omit pid buffer size %d "
-					"exceeded!\n", PIDOF_OMITSZ);
-				closelog();
-				exit(1);
-			}
-			if (strcmp("%PPID",optarg) == 0)
-				opid[oind] = getppid();
-			else if ((opid[oind] = atoi(optarg)) < 1) {
-				nsyslog(LOG_ERR,
-					"illegal omit pid value (%s)!\n",
-					optarg);
-				closelog();
-				exit(1);
+			here = optarg;
+			while ((token = strsep(&here, ",;:"))) {
+				OMIT *restrict optr;
+				pid_t opid;
+
+				if (strcmp("%PPID", token) == 0)
+					opid = getppid();
+				else
+					opid = (pid_t)atoi(token);
+
+				if (opid < 1) {
+					nsyslog(LOG_ERR,
+						"illegal omit pid value "
+						"(%s)!\n", token);
+					continue;
+				}
+				xmemalign((void*)&optr, sizeof(void*), alignof(OMIT));
+				optr->next = omit;
+				optr->prev = (OMIT*)0;
+				optr->pid  = opid;
+				omit = optr;
 			}
-			oind++;
 			flags |= PIDOF_OMIT;
 			break;
 		case 's':
@@ -567,6 +650,9 @@ int main_pidof(int argc, char **argv)
 		case 'x':
 			scripts_too++;
 			break;
+		case 'm':
+			flags |= PIDOF_OMIT_OMIT_MATCHES;
+			break;
 		default:
 			/* Nothing */
 			break;
@@ -588,17 +674,23 @@ int main_pidof(int argc, char **argv)
 	readproc(DO_STAT);
 	for(f = 0; f < argc; f++) {
 		if ((q = pidof(argv[f])) != NULL) {
-			spid = 0;
+			pid_t spid = 0;
 			while ((p = get_next_from_pid_q(q))) {
 				if (flags & PIDOF_OMIT) {
-					for (i = 0; i < oind; i++)
-						if (opid[i] == p->pid)
+					PROC * optr;
+					for (optr = olist; optr; optr = optr->next) {
+						if (optr->pid == p->pid)
 							break;
+						if (flags & PIDOF_OMIT_OMIT_MATCHES)
+							if (matches(optr, p))
+								break;
+					}
+
 					/*
 					 *	On a match, continue with
 					 *	the for loop above.
 					 */
-					if (i < oind)
+					if (optr)
 						continue;
 				}
 				if (flags & PIDOF_SINGLE) {
@@ -626,22 +718,22 @@ int main_pidof(int argc, char **argv)
 	}
 	if (!first)
 		printf("\n");
+
+        clear_omit();
+
 	closelog();
 	return(first ? 1 : 0);
 }
 
 
 
-#define KILLALL_OMITSZ	16
-
 /* Main for either killall or pidof. */
 int main(int argc, char **argv)
 {
 	PROC		*p;
 	int		pid, sid = -1;
-	pid_t		opid[KILLALL_OMITSZ];
-	int		i, oind, omit = 0;
 	int		sig = SIGKILL;
+        int		c;
 
 	/* return non-zero if no process was killed */
 	int		retval = 2;
@@ -660,30 +752,34 @@ int main(int argc, char **argv)
 		return main_pidof(argc, argv);
 
 	/* Right, so we are "killall". */
-	for (oind = KILLALL_OMITSZ-1; oind > 0; oind--)
-		opid[oind] = 0;
+	omit = (OMIT*)0;
 
 	if (argc > 1) {
-		for (i = 1; i < argc; i++) {
-			if (argv[i][0] == '-') (argv[i])++;
-			if (argv[i][0] == 'o') {
-				if (++i >= argc) usage();
-				if (oind >= KILLALL_OMITSZ -1) {
-					nsyslog(LOG_ERR,"omit pid buffer size "
-						"%d exceeded!\n",
-						KILLALL_OMITSZ);
-					closelog();
-					exit(1);
-				}
-				if ((opid[oind] = atoi(argv[i])) < 1) {
-					nsyslog(LOG_ERR,
-						"illegal omit pid value "
-						"(%s)!\n", argv[i]);
-					closelog();
-					exit(1);
+                for (c = 1; c < argc; c++) {
+			if (argv[c][0] == '-') (argv[c])++;
+			if (argv[c][0] == 'o') {
+				char * token, * here;
+
+				if (++c >= argc)
+					usage();
+
+				here = argv[c];
+				while ((token = strsep(&here, ",;:"))) {
+					OMIT *restrict optr;
+					pid_t opid = (pid_t)atoi(token);
+
+					if (opid < 1) {
+						nsyslog(LOG_ERR,
+							"illegal omit pid value "
+							"(%s)!\n", token);
+						continue;
+					}
+					xmemalign((void*)&optr, sizeof(void*), alignof(OMIT));
+					optr->next = omit;
+					optr->prev = (OMIT*)0;
+					optr->pid  = opid;
+					omit = optr;
 				}
-				oind++;
-				omit = 1;
 			}
 			else if ((sig = atoi(argv[1])) <= 0 || sig > 31)
 				usage();
@@ -723,11 +819,14 @@ int main(int argc, char **argv)
 		if (p->pid == 1 || p->pid == pid || p->sid == sid || p->kernel)
 			continue;
 		if (omit) {
-			for (i = 0; i < oind; i++)
-				if (opid[i] == p->pid)
+			OMIT * optr;
+			for (optr = omit; optr; optr = optr->next) {
+				if (optr->pid == p->pid)
 					break;
+			}
+
 			/* On a match, continue with the for loop above. */
-			if (i < oind)
+			if (optr)
 				continue;
 		}
 		kill(p->pid, sig);
-- 
1.8.3.1

